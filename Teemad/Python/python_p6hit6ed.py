# -*- coding: utf-8 -*-
"""Python_p6hit6ed.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s4wI7Vq08k4W0ZjujBRykceC9xiaKFtH

# Pythoni põhitõed

1. Väärtuste omistamine muutujatele
"""

# Täisarvu väärtuse omistamine
age = 30

# Stringi väärtuse omistamine
name = "Alice"

# Ujukomaarvu väärtuse omistamine
height = 5.9

"""2. Muutujate kasutamine"""

# Muutujate väljastamine
print(age)  # Väljund: 30
print(name)  # Väljund: Alice
print(height)  # Väljund: 5.9

# Muutujate kasutamine arvutustes
next_year_age = age + 1
print(next_year_age)  # Väljund: 31

"""3. Muutujate uuendamine"""

# Muutuja uuendamine
age = age + 1
print(age)  # Väljund: 31

# Muutuja suurendamine (lühem viis)
age += 1
print(age)  # Väljund: 32

"""# Sisseehitatud funktsioonid

`print()` - kasutatakse andmete väljastamiseks ekraanile. Näide: `print("Tere, maailm!")`.

`len()` - tagastab objekti pikkuse (elementide arvu). Näide: `len("Python")` tagastab 6.

`type()` - tagastab objekti tüübi. Näide: `type(123)` tagastab `<class 'int'>`.

`int()` ja `str()` - kasutatakse tüübimuundeks. `int()` teisendab täisarvuks, `str()` stringiks. Näide: `int("10") [link text](https://)` tagastab 10; `str(10)` tagastab "10".

# Kuidas kasutada f-stringe:

F-stringi loomiseks lisa stringi ette täht `f` või `F`. Pane muutujad või väljendid lokkklambrite {} sisse stringi sees, need asendatakse otse nende väärtustega.
"""

name = "Alice"
city = "London"

# F-stringi kasutamine nime ja linna lisamiseks väljundisse
greeting = f"Tere, minu nimi on {name} ja elan linnas {city}."

print(greeting) # Väljund: Tere, minu nimi on Alice ja elan linnas London.

price = 19.99
quantity = 3

# Väljendi kasutamine f-stringis
total = f"Kokku: €{price * quantity:.2f}"

print(total) # Väljund: Kokku: €59.97

"""# Andmetüübid

# Põhilised andmetüübid

Täisarvud `(int)`: Täisarvud, positiivsed või negatiivsed, ilma komakohtadeta. Nt: 5, -3.

Ujukomaarvud `(float)`: Arvud, millel on komakoht või eksponentsiaalne (E) vorm. Nt: 3.14, -0.001, 2e2.

Tõeväärtused `(bool)`: Esindavad väärtusi `True` või `False`.

# Jada tüübid

Stringid `(str)`: Unicode'i märkide jada. Nt: `"Tere, maailm!"`.

Listid `(list)`: Järjestatud ja muudetavad elementide kogumid. Nt: `[1, 2.5, 'Python']`.

Tuplid `(tuple)`: Järjestatud ja muutmatud elementide kogumid. Nt: (1, 2.5, 'Python').

Vahemikud `(range)`: Muutmatud arvujadad, mida kasutatakse tihti tsüklites.

# Kaardistamise tüüp

Sõnastikud `(dict)`: Võtme-väärtuse paaride kogumid. Nt: `{'nimi': 'Alice', 'vanus': 30}`.

# Hulgatüübid

Hulgad `(set)`: Järjestamata ja indekseerimata unikaalsete elementide kogumid. Nt: `{1, 2, 3, 'Python'}`.

Külmutatud hulgad (frozenset): Muutmatud hulgad. Nt: `frozenset([1, 2, 3, 'Python'])`.

On veel mõned keerukamad tüübid. Täpsemalt vaata: https://docs.python.org/3.12/library/stdtypes.html

# Andmetüübi info saamine

Andmetüübi määramiseks kasuta funktsiooni `type()`.

```
x = 5

print(type(x))  # Väljund: <class 'int'>
```

# Andmetüüpide teisendamine

Python võimaldab teisendada andmetüüpe, kui see on loogiliselt võimalik.


```
# Täisarvu teisendamine ujukomaarvuks
x = 10
print(float(x))  # Väljund: 10.0

# Ujukomaarvu teisendamine täisarvuks (komakohad eemaldatakse)
y = 3.14
print(int(y))  # Väljund: 3

# Arvu teisendamine stringiks
z = 20
print(str(z))  # Väljund: '20'

# Tupli teisendamine listiks
t = (1,2,3)
print(list(t)) # Väljund: [1, 2, 3]

# Listi teisendamine hulgaks
l = [1, 2, 3, 4, 2, 4, 3, 5, 5]
print(set(l)) # Väljund: {1, 2, 3, 4, 5}
```

# Võrdlusoperaatorid

Võrdne `(==)`: Kontrollib, kas kahe operandi väärtused on võrdsed.

Mitte võrdne `(!=)`: Kontrollib, kas kahe operandi väärtused ei ole võrdsed.

Suurem kui `(>)`: Kontrollib, kas vasakpoolne operand on suurem kui parempoolne.

Väiksem kui `(<)`: Kontrollib, kas vasakpoolne operand on väiksem kui parempoolne.

Suurem või võrdne `(>=)`: Kontrollib, kas vasakpoolne operand on suurem või võrdne parempoolsega.

Väiksem või võrdne `(<=)`: Kontrollib, kas vasakpoolne operand on väiksem või võrdne parempoolsega.

# Võrdlusoperaatorite kasutamine


```
a = 10
b = 20

# Võrdne
print(a == b)  # Väljund: False

# Mitte võrdne
print(a != b)  # Väljund: True

# Suurem kui
print(a > b)  # Väljund: False

# Väiksem kui
print(a < b)  # Väljund: True

# Suurem või võrdne
print(a >= 10)  # Väljund: True

# Väiksem või võrdne
print(b <= 20)  # Väljund: True
```

# Loogikaoperaatoritega kombineerimine

Python võimaldab kombineerida võrdlusoperaatoreid loogikaoperaatoritega `(and, or, not)`, et luua keerukamaid tingimusi.

Võrdlusoperaatorite kasutamine on oluline otsuste tegemisel Pythonis. Neid kasutatakse laialdaselt juhtimisloogikas nagu `if`-lause, tsüklid `(while, for)` ja listikomprehensioonid.


```
 = 5
y = 10

# Kas x on suurem kui 3 ja väiksem kui 10
print(x > 3 and x < 10)  # Väljund: True; sama mis print(3 < x < 10)

# Kas x on väiksem kui 4 või y suurem kui 8
print(x < 4 or y > 8)  # Väljund: True

# 'not' pöörab tulemuse vastupidiseks
print(not(x > 3 and x < 10))  # Väljund: False
```

# Täiendavad võrdlusoperaatorid

# Identiteedi operaatorid

Identiteedi operaatorid võrdlevad kahe objekti mälu asukohti. Need ei puuduta väärtuse võrdsust, vaid seda, kas nad on tegelikult sama objekt.

`is`: Tõene, kui operandid on identsed (viitavad samale objektile)

`is not`: Tõene, kui operandid ei ole identsed (ei viita samale objektile)

```
a = [1, 2, 3]
b = a       # b viitab samale nimekirjale nagu a
c = a[:]    # c on a koopia, kuid osutab teisele objektile
# ülaltoodud rida on ekvivalentne `c = a.copy()`

# Kasutades 'is'
print(a is b)  # Väljund: True

# Kasutades 'is not'
print(a is not c)  # Väljund: True

print(a is not None) # Väljund: True
```


# Kuuluvuse operaatorid

Kuuluvuse operaatorid testivad, kas järjestus sisaldab määratud väärtust.

`in`: Tõene, kui väärtus leidub järjestuses

`not in`: Tõene, kui väärtus ei leia järjestuses



```
my_list = [1, 2, 3, 4, 5]

# Kasutades 'in'
print(3 in my_list)  # Väljund: True

# Kasutades 'not in'
print(6 not in my_list)  # Väljund: True
```

# NB! Pane tähele!

`= `on omistusoperaator, millega omistatakse väärtus muutujale,

vs.

`==` on võrdlusoperaator, millega võrreldakse kahe väärtuse võrdsust.
________________

`is` operaator kontrollib, kas kaks operandit viitavad samale objektile mälus (identiteet)

vs

`==` kontrollib, kas kahe operandi väärtused on võrdsed (võrdsus).

# Tingimuslause

`if`-lause: Käivitab koodiploki, kui tingimus on tõene.

`elif`-lause: Lühend sõnast 'else if'; võimaldab kontrollida mitut tingimust pärast if-lause täitmist.

`else`-lause: Käivitab koodiploki, kui kõik eelnevad tingimused on väärad.


```
age = 20
if age < 18:
    print("Oled alaealine.")
elif age >= 18 and age < 65:
    print("Oled täiskasvanu.")
else:
    print("Oled eakas.")
```

# Tsüklid

Pythonis on kahte tüüpi tsükleid:

`for` tsükkel: Kasutatakse järjestuste (nimekiri, tupli, sõnastik, hulk, string) läbimiseks.

```
fruits = ["õun", "banaan", "kirss"]
for fruit in fruits:
    print(fruit)
```

`while` tsükkel: Kordab tegevust seni, kuni tingimus on tõene.

Ole ettevaatlik `while`-tsüklitega; ilma lõpetava tingimuseta võib tekkida lõputu tsükkel, mis jääb igavesti käima ja võib programmi hanguma panna.

```
count = 5
while count > 0:
    print(count)
    count -= 1
```

# Tsükli juhtkäsud

`break`: Väljub tsüklist.


```
for num in range(1, 10):
    if num == 5:
        break  # Välju tsüklist, kui num on 5
    if num % 2 == 0:
        continue  # Jäta paarisarvud vahele
    print(num)
```



`continue`: Jätab ülejäänud koodi vahele ja liigub järgmise iteratsiooni juurde.

`pass`: Ei tee midagi; kasutatakse kohatäitena.

# Pesastatud tsüklid

Tsükleid saab üksteise sisse pesastada.



```
for i in range(1, 4):  # Välimine tsükkel
    for j in range(1, 3):  # Sisemine tsükkel
        print(f"i = {i}, j = {j}")
```

# Taande olulisus

Taane on vajalik:

Tingimuslaused (`if, elif, else`)

Tsüklid (`for, while`)

Funktsioonide ja klasside definitsioonid

Kontekstihalduriga (`with`-lause)

`try-except` plokkides

# Funktsiooni defineerimine

kasuta märksõna `def`, sellele järgneb funktsiooni nimi, sulud `()`, ja koolon `:`.

Kooloni järel olev taandega koodiplokk käivitatakse, kui funktsioon välja kutsutakse.


```
def tervita_kasutajat(kasutajanimi):  # 'kasutajanimi' on parameeter
    '''Kuvab lihtsa tervituse.'''
    print(f"Tere, {kasutajanimi}!")
```

# Parameetrid ja argumendid

**Parameetrid** on muutujad, kuhu argument salvestatakse, kui funktsioon välja kutsutakse.

**Argumendid** on väärtused, mis antakse funktsiooni parameetritele.
Tagastusväärtused

# Funktsioonist väärtuse tagastamiseks

kasuta `return`-lauset:



```
def liida_arvud(x, y): # siin x ja y on parameetrid
    return x + y

# Tulemus salvestatakse muutujasse:
tulemus = liida_arvud(3, 5) # siin 3 ja 5 on argumendid
print(tulemus)  # Väljund: 8
```

# Skoop ja taane

**Globaalne skoop**: Muutujad, mis on defineeritud mooduli ülemisel tasemel või väljaspool funktsioone, on globaalses skoopis.

**Kohalik skoop**: Muutujad, mis on defineeritud funktsiooni sees, on selle funktsiooni kohalikus skoopis ja pole väljastpoolt kättesaadavad.



```
x = "globaalne"  # Globaalne skoop

def funktsiooni_skoop():
    y = "kohalik"  # Kohalik skoop
    print(x)  # Kättesaadav: väljastab 'globaalne'
    print(y)  # Kättesaadav: väljastab 'kohalik'

funktsiooni_skoop()
print(x)  # Kättesaadav: väljastab 'globaalne'
#print(y)  # Viga: 'y' pole siin kättesaadav; see defineeriti funktsiooni_skoop sees
```

# Protseduuriline programmeerimine Pythonis

soodustab taaskasutatavate koodiplokkide (funktsioonide) kasutamist ja aitab koodi paremini organiseerida ja hallata, eriti algajatele või olukordades, kus objektorienteeritud programmeerimine oleks liigne.



```
# Funktsioon, mis arvutab vanuse sünniaasta põhjal
def arvuta_vanus(sunniaasta):
    praegune_aasta = 2023  # Eeldame, et praegune aasta on 2023
    vanus = praegune_aasta - sunniaasta
    return vanus

# Funktsioon, mis kontrollib, kas kasutaja on täisealine (18+)
def on_taisealine(vanus):
    return vanus >= 18

# Funktsioon, mis tervitab kasutajat vastavalt täisealisusele
def tervita_kasutajat(nimi, taisealine):
    if taisealine:
        return f"Tere tulemast, {nimi}! Oled täisealine."
    else:
        return f"Tere, {nimi}! Sa ei ole veel täisealine."

# Funktsioon, mis võtab kasutaja info kokku
def kokkuvote_kasutajast(nimi, sunniaasta):
    vanus = arvuta_vanus(sunniaasta)
    taisealine = on_taisealine(vanus)
    tervitus = tervita_kasutajat(nimi, taisealine)
    print(f"{tervitus} Sinu vanus on {vanus} aastat.")

# Peamine töövoog
def main():
    kasutaja_nimi = "Alice"
    sunniaasta = 2005
    kokkuvote_kasutajast(kasutaja_nimi, sunniaasta)

# Käivita peafunktsioon
main()
```

# Faili avamine `with`-lausega

`with`-lause lihtsustab erindite käsitlemist, kapseldades ettevalmistus- ja puhastustoimingud kontekstihaldurisse.

Failioperatsioonide puhul tähendab see faili avamist ja kindlust, et see suletakse.



```
with open('drive/MyDrive/example.txt', 'r') as file:
    content = file.read()
    print(content)

print('\n  -----------------------------------')
print(' | Nüüd uuesti, aga `readlines` abil |')
print('  -----------------------------------\n')

with open('drive/MyDrive/example.txt', 'r') as file:
    lines = file.readlines()
    for line in lines:
        print(line.strip())  # Kasutame strip(), et eemaldada reavahetus
```

Funktsioon `readlines() `loeb kõik faili read nimekirja. Iga nimekirja element esindab ühte faili rida, sisaldades ka reavahetuse märki `(\n)` iga rea lõpus.

See meetod on eriti kasulik, kui on vaja töödelda faili ridu ükshaaval, näiteks andmete parsimiseks või iga rea kohta toimingu tegemiseks.

# Teksti kirjutamine faili

Teksti kirjutimiseks faili kasuta funktsiooni `open()` režiimiga '`w`' `(write)`.

Kui faili pole olemas, luuakse see. Kui fail on olemas, kirjutatakse see üle.

Vaata ka `print()` dokumentatsiooni



```
with open('output.txt', 'w') as fh: #fh tähendab 'file handle'
    print('Tere, Python!', file=fh)
```

# Teksti lisamine olemasolevasse faili

Kui soovid lisada teksti olemasolevasse faili ilma selle sisu üle kirjutamata, kasuta režiimi '`a`' `(append)` režiimi '`w`' asemel.



```
my_new_lines = ['Mõned', 'uued', 'read']

with open('output.txt', 'a') as fh:
    for line in my_new_lines:
      print(line, file=fh)
```

See lisab faili lõppu `'\nMõned\nuued\nread\n'`, ilma olemasolevat sisu kustutamata.

# Vigade käsitlemine

Python kasutab erindeid `(exceptions)`, et hallata vigu, mis tekivad programmi täitmise ajal. Õige erindite käsitlemine aitab vältida programmi kokkujooksmist ja anda kasutajale või arendajale arusaadavaid veateateid.

Kasuta `try-except` plokke

Pane kood, mis võib erindi tekitada, `try`-plokki ja püüa erindid `except`-plokiga.

Alati püüa konkreetseid erindeid, mitte ära kasuta paljast `except:` lauset. Kõigi erindite püüdmine võib varjata tegelikke vigu ja raskendada silumist.


```
try:
    # Kood, mis võib erindi tekitada
except MõniErind:
    # Erindi käsitlemine
```


```
try:
    # Riskantne operatsioon
except ValueError:
    # Käsitle konkreetset erindit
except TypeError:
    # Käsitle teist konkreetset erindit
```

# Resursside puhastamine `finally`-plokiga

Kasuta `finally`-plokki, et vabastada ressursid või teha puhastustoimingud, sõltumata sellest, kas erind tekkis või mitte.



```
try:
    # Faili avamine või ressursi hankimine
except IOError:
    # Faili I/O vead
finally:
    # Faili sulgemine või ressursi vabastamine
```

# Kasuta silurit

Kasuta Python'i sisseehitatud silurit `pdb`, et koodi samm-sammult läbi käia, vaadata muutujate väärtusi ja täita koodi rida-realt.



```
python -m pdb sinu_skript.py
```

# Teekide kasutamine Pythonis

Pythonis on teegid `(libraries)` korduvkasutatavate moodulite ja pakettide kogumid, mis pakuvad lisafunktsionaalsust väljaspool standardkeelt.

Teegid aitavad arendusaega oluliselt vähendada, pakkudes valmis lahendusi paljudele rakendustele, alates veebiarendusest ja andmete visualiseerimisest kuni masinõppe ja teadusliku arvutamiseni.

# Standardteegid

Pythoniga kaasas olev standardteek on võimas tööriist, mis sisaldab mooduleid süsteemifunktsioonide, failide I/O, stringitöötluse, võrgusuhtluse ja muu jaoks.

Kuna standardteek on osa igast Python'i paigaldusest, saab neid funktsioone kasutada ilma midagi juurde installimata. See on platvormideülene ja töötab ühtemoodi erinevates operatsioonisüsteemides.

# Välised teegid

Välised teegid ei kuulu vaikimisi Python'i paigaldusse ja tuleb eraldi paigaldada, näiteks tööriistaga `pip` (Python'i paketihaldur). Neid arendab ja haldab ülemaailmne Python'i kogukond ning need on kättesaadavad platvormidel nagu Python Package Index `(PyPI)`.

Välised teegid laiendavad Python'i võimalusi veelgi, võimaldades arendajatel kasutada keerukaid funktsioone ja algoritme ilma neid ise nullist kirjutamata.



```
import os
import shutil

def organize_directory(directory_path):
    # Loetle kõik failid kataloogis
    files = os.listdir(directory_path)

    for file in files:
        # Jäta kataloogid vahele
        if os.path.isfile(os.path.join(directory_path, file)):
            # Eralda failinimi ja laiend
            _, extension = os.path.splitext(file)
            if extension:  # Kontrolli, kas failil on laiend
                extension = extension[1:]  # Eemalda punkt laiendist
                # Määra laiendi kataloogi tee
                extension_dir = os.path.join(directory_path, extension)
                # Kontrolli, kas laiendi kataloog on olemas
                if not os.path.exists(extension_dir):
                    os.makedirs(extension_dir)  # Loo kataloog, kui seda pole
                # Liiguta fail vastava laiendi kataloogi
                shutil.move(os.path.join(directory_path, file), extension_dir)

# Näide kasutusest
# organize_directory('/path/to/your/directory')
```

# Klasside kasutamine Pythonis: sissejuhatus OOP-sse

Objektorienteeritud programmeerimine `(OOP)` on programmeerimisparadigma, mis kasutab 'objekte' andmete ja meetodite esitamiseks. Python toetab OOP-d paindliku klassimehhanismiga, võimaldades luua elegantseid ja võimsaid koodistruktuure.

# OOP põhimõisted

`Klass`: Mall objektide loomiseks. Klassid kapseldavad objekti andmed ja meetodid nende töötlemiseks.

`Objekt`: Klassist loodud eksemplar. Igal objektil võivad olla unikaalsed omadused ja käitumine, nagu klassis määratud.

`Pärilikkus`: Võimaldab klassil pärida atribuute ja meetodeid teiselt klassilt.

`Kapseldamine`: Piirab ligipääsu meetoditele ja muutujatele, et vältida andmete otsest muutmist (avalik vs privaatne).

`Polümorfism`: Võimaldab meetoditel teha erinevaid asju sõltuvalt objektist, millel neid kasutatakse.

# Klassi defineerimine Pythonis

Klassi defineerimiseks kasuta märksõna `class:`



```
lass MinuKlass:
    x = 5

# Klassi eksemplari loomine:
p1 = MinuKlass()
print(p1.x)
```

# Klasside defineerimine


```
class Punkt:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __str__(self):
        return f"({self.x}, {self.y})"

    def kaugus(self, p):
        return ((self.x - p.x) ** 2 + (self.y - p.y) ** 2) ** 0.5

class Joon:
    def __init__(self, alguspunkt, loppunkt):
        self.algus = alguspunkt
        self.lopp = loppunkt

    def __str__(self):
        return f"Joon({self.algus} kuni {self.lopp})"

    def pikkus(self):
        return self.algus.kaugus(self.lopp)
```

# Klasside kasutamine



```
# Punktide loomine
p1 = Punkt(1, 2)
p2 = Punkt(4, 6)

# Joone loomine p1-st p2-ni
j = Joon(p1, p2)

print(j)  # Väljund: Joon((1, 2) kuni (4, 6))
print(f"Joone pikkus: {j.pikkus()}")  # Arvutab vektori pikkuse
```

# Koodi kirjutamine Jupyter Notebookis (see dokument)

Jupyter Notebookis kirjutad ja käivitad oma Python koodi interaktiivsetes lahtrites. Iga lahtrit saab eraldi käivitada, mis võimaldab kohest tagasisidet ja interaktiivset programmeerimiskogemust. Notebookid sobivad suurepäraselt andmeanalüüsiks, visualiseerimiseks ja samm-sammulisteks juhenditeks.

# Python skripti kirjutamine

Kui soovid oma koodi viia skripti, mida saab käsurealt käivitada, loo `.py` fail. See fail sisaldab sinu Python koodi lihttekstina, järjestatult täitmise järjekorras.

Loo .py fail: Ava oma tekstiredaktor või IDE ja loo uus fail laiendiga `.py`, näiteks `skript.py`.

Kopeeri kood: Tõsta Python kood Jupyter Notebookist sellesse faili. Erinevalt notebookist pole seal interaktiivseid lahtrid, seega korralda kood loogiliselt ülalt alla.
Kohanda koodi (vajadusel): Kui notebookis on interaktiivseid elemente (nt sisendi küsimine) või kood sõltub lahtrite täitmise järjekorrast, kohanda koodi nii, et see töötaks skriptina.
Skripti käivitamine käsurealt

# Python skripti käivitamiseks käsurealt toimi nii:

Ava terminal või käsurida: Liigu kausta, kus asub sinu .py fail.
Käivita skript: Sisesta `python skript.py` (asenda skript.py oma faili nimega) ja vajuta Enter.

Näide käsurea käsust

`python skript.py`

See käsk annab Pythonile korralduse tõlgendada sinu skriptifaili ja käivitada selles olev kood. Veendu, et Python oleks arvutisse paigaldatud ja käsurealt kättesaadav. Pythoni versioon (nt Python 2 vs Python 3) ja tee võivad sõltuda sinu paigaldusest ja keskkonnast.

# Kokkuvõte

Notebookist eraldiseisva Python skripti loomine on väärtuslik oskus, eriti projektide juurutamiseks, ülesannete automatiseerimiseks või tarkvara arendamiseks. Jupyter Notebook pakub suurepärast interaktiivset keskkonda arenduseks ja õpetamiseks, kuid Python skriptid sobivad paremini tervikprogrammide käivitamiseks ja töövoogude automatiseerimiseks käsurealt.
"""